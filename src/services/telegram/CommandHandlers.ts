import { Context } from 'telegraf';
import { TelegramServices } from './types';
import { UIComponents } from './UIComponents';

/**
 * Command handlers for the Telegram bot
 * Handles all /command interactions
 */
export class CommandHandlers {
  private services: TelegramServices;
  private ui: UIComponents;

  constructor(services: TelegramServices) {
    this.services = services;
    this.ui = new UIComponents();
  }

  /**
   * Handle /start command - Creates wallet for new users
   */
  async handleStartCommand(ctx: Context): Promise<void> {
    try {
      const telegramId = ctx.from?.id?.toString();
      
      if (!telegramId) {
        await ctx.reply('‚ùå Unable to identify user. Please try again.');
        return;
      }

      // Check if user already has a wallet
      const hasWallet = await this.services.walletService.hasWallet(telegramId);
      
      await ctx.reply(
        this.ui.getWelcomeMessage(hasWallet),
        this.ui.getMainMenuKeyboard()
      );
      
    } catch (error) {
      console.error('Error in start command:', error);
      await ctx.reply(
        '‚ùå Failed to load main menu. Please try again later or contact support.'
      );
    }
  }

  /**
   * Handle /wallet command - Show wallet information with tokens
   */
  async handleWalletCommand(ctx: Context): Promise<void> {
    try {
      const telegramId = ctx.from?.id?.toString();
      
      if (!telegramId) {
        await ctx.reply('‚ùå Unable to identify user.');
        return;
      }

      const hasWallet = await this.services.walletService.hasWallet(telegramId);
      
      if (!hasWallet) {
        await ctx.reply(
          '‚ùå You don\'t have a wallet yet.\n\n' +
          'Use /start to create your Web3 wallet.'
        );
        return;
      }

      // Use WalletOperations to show wallet with tokens
      await this.services.walletOperations.showWallet(ctx);
      
    } catch (error) {
      console.error('Error in wallet command:', error);
      await ctx.reply('‚ùå Failed to retrieve wallet information.');
    }
  }

  /**
   * Handle /tokens command - Show token balances
   */
  async handleTokensCommand(ctx: Context): Promise<void> {
    try {
      const telegramId = ctx.from?.id?.toString();
      
      if (!telegramId) {
        await ctx.reply('‚ùå Unable to identify user.');
        return;
      }

      const hasWallet = await this.services.walletService.hasWallet(telegramId);
      
      if (!hasWallet) {
        await ctx.reply(
          '‚ùå You don\'t have a wallet yet.\n\n' +
          'Use /start to create your Web3 wallet.'
        );
        return;
      }

      await this.services.walletOperations.showTokenBalances(ctx);
      
    } catch (error) {
      console.error('Error in tokens command:', error);
      await ctx.reply('‚ùå Failed to retrieve token information.');
    }
  }

  /**
   * Handle /transfer command - Start token transfer
   */
  async handleTransferCommand(ctx: Context): Promise<void> {
    try {
      const telegramId = ctx.from?.id?.toString();
      
      if (!telegramId) {
        await ctx.reply('‚ùå Unable to identify user.');
        return;
      }

      const hasWallet = await this.services.walletService.hasWallet(telegramId);
      
      if (!hasWallet) {
        await ctx.reply(
          '‚ùå You don\'t have a wallet yet.\n\n' +
          'Use /start to create your Web3 wallet.'
        );
        return;
      }

      await this.services.walletOperations.startTokenTransfer(ctx);
      
    } catch (error) {
      console.error('Error in transfer command:', error);
      await ctx.reply('‚ùå Failed to start token transfer.');
    }
  }

  /**
   * Handle /help command
   */
  async handleHelpCommand(ctx: Context): Promise<void> {
    const helpMessage = `ü§ñ **Deffy DAO Bot - Help Guide**\n\n` +
      `**üèõÔ∏è DAO Management**\n` +
      `‚Ä¢ \`/create_dao\` - Create a new DAO\n` +
      `‚Ä¢ \`/my_dao\` - View your DAOs\n` +
      `‚Ä¢ \`/propose <dao_id> | <title> | <description>\` - Create proposal\n` +
      `‚Ä¢ \`/vote <proposal_id> | <yes/no>\` - Vote on proposals\n\n` +
      `**üíº Wallet Management**\n` +
      `‚Ä¢ \`/wallet\` - View wallet info with tokens\n` +
      `‚Ä¢ \`/tokens\` - View token balances\n` +
      `‚Ä¢ \`/transfer\` - Transfer tokens\n` +
      `‚Ä¢ \`/start\` - Create wallet (first time)\n\n` +
      `**üè¶ Treasury Management**\n` +
      `‚Ä¢ \`/create_vault\` - Create treasury vault\n` +
      `‚Ä¢ \`/vault\` - View vault info\n` +
      `‚Ä¢ \`/deposit\` - Deposit to vault\n` +
      `‚Ä¢ \`/withdraw\` - Withdraw from vault\n\n` +
      `**üîí Security Features**\n` +
      `‚Ä¢ All private keys are encrypted\n` +
      `‚Ä¢ Secure blockchain transactions\n` +
      `‚Ä¢ Decentralized governance\n\n` +
      `**üìä Current Status: Phase 4**\n` +
      `‚úÖ Wallet Creation\n` +
      `‚úÖ DAO Creation & Management\n` +
      `‚úÖ Proposal & Voting System\n` +
      `‚úÖ Treasury Vaults\n\n` +
      `Need help? Contact support or check our documentation.`;

    await ctx.reply(helpMessage, { 
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[
          { text: 'üîô Back to Main Menu', callback_data: 'back_to_main' }
        ]]
      }
    });
  }

  /**
   * Handle /my_dao command
   */
  async handleMyDAOCommand(ctx: Context): Promise<void> {
    try {
      const telegramId = ctx.from?.id?.toString();
      
      if (!telegramId) {
        await ctx.reply('‚ùå Unable to identify user.');
        return;
      }

      // Check if user has a wallet
      const hasWallet = await this.services.walletService.hasWallet(telegramId);
      if (!hasWallet) {
        await ctx.reply(
          '‚ùå You need a wallet first!\n\n' +
          'Use /start to create your Web3 wallet.'
        );
        return;
      }

      await ctx.reply('üîÑ Loading your DAO information...');

      // Get user's DAOs
      const userDAOs = await this.services.daoService.getUserDAOs(telegramId);
      
      if (userDAOs.length === 0) {
        await ctx.reply(
          'üìä My DAO Dashboard\n\n' +
          'üèõÔ∏è No DAOs Found\n\n' +
          'You haven\'t created or joined any DAOs yet.\n\n' +
          'Use /create_dao to create your first DAO!',
          { 
            parse_mode: undefined,
            reply_markup: {
              inline_keyboard: [[
                { text: 'üîô Back to Main Menu', callback_data: 'back_to_main' }
              ]]
            }
          }
        );
        return;
      }

      let response = `üìä My DAO Dashboard\n\n`;
      response += `üèõÔ∏è Your DAOs (${userDAOs.length}/5)\n\n`;

      for (const dao of userDAOs) {
        response += `üèõÔ∏è ${dao.name}\n`;
        response += `üìù ${dao.description}\n`;
        response += `üÜî Address: ${dao.address}\n`;
        response += `üë• Members: ${dao.memberCount}\n`;
        response += `üìã Total Proposals: ${dao.proposalCount}\n`;
        
        // Skip expensive proposal fetching for faster response
        // Users can use callback interface for detailed proposal info
        response += `üî• Active Proposals: Use main menu for details\n\n`;
        response += `---\n\n`;
      }

      response += `Commands:\n`;
      response += `‚Ä¢ /propose <dao_id> | <title> | <description>\n`;
      response += `‚Ä¢ /vote <proposal_id> | <yes/no>\n`;
      response += `‚Ä¢ /create_dao - Create new DAO`;

      await ctx.reply(response, { 
        parse_mode: undefined,
        reply_markup: {
          inline_keyboard: [[
            { text: 'üîô Back to Main Menu', callback_data: 'back_to_main' }
          ]]
        }
      });
      
    } catch (error) {
      console.error('Error in my_dao command:', error);
      await ctx.reply('‚ùå Failed to load DAO dashboard.');
    }
  }

  /**
   * Handle /propose command
   */
  async handleProposeCommand(ctx: Context): Promise<void> {
    try {
      const telegramId = ctx.from?.id?.toString();
      const chatType = ctx.chat?.type;
      
      if (!telegramId) {
        await ctx.reply('‚ùå Unable to identify user.');
        return;
      }

      // Check if user has a wallet
      const hasWallet = await this.services.walletService.hasWallet(telegramId);
      if (!hasWallet) {
        await ctx.reply(
          '‚ùå You need a wallet first!\n\n' +
          'Use /start to create your Web3 wallet.'
        );
        return;
      }

      const contextInfo = chatType === 'group' || chatType === 'supergroup' ? 
        '\n\nüë• **Group Proposal**\nThis proposal will be visible to all group members.' : 
        '\n\nüë§ **Personal Proposal**\nManage proposals for your DAOs.';

      await ctx.reply(
        `üìù **Create Proposal**\n\n` +
        `Please provide the following information:\n\n` +
        `**Format:** \`/propose <dao_id> | <title> | <description>\`\n\n` +
        `**Example:** \`/propose dao123 | Increase treasury allocation | Proposal to allocate 10% more to development\`\n\n` +
        `**Parameters:**\n` +
        `‚Ä¢ **DAO ID:** The DAO to create proposal for\n` +
        `‚Ä¢ **Title:** Proposal title (max 100 characters)\n` +
        `‚Ä¢ **Description:** Detailed description (max 500 characters)${contextInfo}\n\n` +
        `Use /my_dao to see your available DAOs.`,
        { parse_mode: 'Markdown' }
      );
      
    } catch (error) {
      console.error('Error in propose command:', error);
      await ctx.reply('‚ùå Failed to process proposal request.');
    }
  }

  /**
   * Handle /vote command
   */
  async handleVoteCommand(ctx: Context): Promise<void> {
    try {
      const telegramId = ctx.from?.id?.toString();
      const chatType = ctx.chat?.type;
      
      if (!telegramId) {
        await ctx.reply('‚ùå Unable to identify user.');
        return;
      }

      // Check if user has a wallet
      const hasWallet = await this.services.walletService.hasWallet(telegramId);
      if (!hasWallet) {
        await ctx.reply(
          '‚ùå You need a wallet first!\n\n' +
          'Use /start to create your Web3 wallet.'
        );
        return;
      }

      const contextInfo = chatType === 'group' || chatType === 'supergroup' ? 
        '\n\nüë• **Group Voting**\nView and vote on group proposals.' : 
        '\n\nüë§ **Personal Voting**\nManage votes across your DAOs.';

      await ctx.reply(
        `üó≥Ô∏è **Vote on Proposals**\n\n` +
        `Please provide the following information:\n\n` +
        `**Format:** \`/vote <proposal_id> | <yes/no>\`\n\n` +
        `**Example:** \`/vote prop123 | yes\`\n\n` +
        `**Parameters:**\n` +
        `‚Ä¢ **Proposal ID:** The proposal to vote on\n` +
        `‚Ä¢ **Vote:** Either "yes" or "no"${contextInfo}\n\n` +
        `Use /my_dao to see active proposals in your DAOs.`,
        { parse_mode: 'Markdown' }
      );
      
    } catch (error) {
      console.error('Error in vote command:', error);
      await ctx.reply('‚ùå Failed to process voting request.');
    }
  }

  /**
   * Handle /create_dao command
   */
  async handleCreateDAOCommand(ctx: Context): Promise<void> {
    try {
      const telegramId = ctx.from?.id?.toString();
      
      if (!telegramId) {
        await ctx.reply('‚ùå Unable to identify user.');
        return;
      }

      // Check if user has a wallet
      const hasWallet = await this.services.walletService.hasWallet(telegramId);
      if (!hasWallet) {
        await ctx.reply(
          '‚ùå **Wallet Required**\n\n' +
          'You need a wallet to create DAOs. Use /start to create your Web3 wallet first.',
          { parse_mode: 'Markdown' }
        );
        return;
      }

      // Check if user already has maximum DAOs (using faster count method)
      const userDAOCount = await this.services.daoService.getUserDAOCount(telegramId);
      if (userDAOCount >= 5) {
        await ctx.reply(
          '‚ùå **DAO Limit Reached**\n\n' +
          `You can only create up to 5 DAOs. You currently have ${userDAOCount} DAOs.\n\n` +
          'Use /my_dao to manage your existing DAOs.',
          { parse_mode: 'Markdown' }
        );
        return;
      }

      await ctx.reply(
        'üèõÔ∏è **Create New DAO**\n\n' +
        'Use the main menu to start the DAO creation process with a guided interface.\n\n' +
        'Click /start to access the main menu with DAO creation options.',
        { parse_mode: 'Markdown' }
      );
      
    } catch (error) {
      console.error('Error in create_dao command:', error);
      await ctx.reply('‚ùå Failed to process DAO creation request.');
    }
  }

  /**
   * Handle vault-related commands
   */
  async handleCreateVaultCommand(ctx: Context): Promise<void> {
    await ctx.reply('üè¶ Vault creation feature coming soon!');
  }

  async handleVaultCommand(ctx: Context): Promise<void> {
    await ctx.reply('üè¶ Vault management feature coming soon!');
  }

  async handleDepositCommand(ctx: Context): Promise<void> {
    await ctx.reply('üí∞ Deposit feature coming soon!');
  }

  async handleWithdrawCommand(ctx: Context): Promise<void> {
    await ctx.reply('üí∏ Withdraw feature coming soon!');
  }
}